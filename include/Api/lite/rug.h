/*******************************************************************************
Copyright (c) 1999-2009 by Text Analysis International, Inc.
All rights reserved.
********************************************************************************
*
* NAME:	RUG.H
* FILE:	include/API/lite/rug.h
* CR:		05/11/99 AM.
* SUBJ:	Top-level class for RUG rule generation library.
* NOTE:	12/11/99 AM. Folding into LITE LIBRARY.
*
*******************************************************************************/


#ifndef RUG_H_
#define RUG_H_

//LIBRUG_API void rug_counts();										// 12/11/99 AM.

// Forward references
//class Xxx;
class Eana;							// 10/13/99 AM.
class Mode;							// 04/04/00 AM.

/********************************************
* CLASS:	RUG
* CR:		05/11/99 AM.
* SUBJ:	API Class for the RUG library.
********************************************/

class LITE_API RUG														// 12/11/99 AM.
{

public:

	RUG(										// Default constructor.
		CONCEPT *gram   = 0,
		NLP     *nlp    = 0,
		_TCHAR    *appdir = 0,
		CG *cg = 0							// 05/17/99 AM.
		);

	~RUG();									// Destructor.

	// Access
	CONCEPT *getGram();
	NLP *getNLP();
	std::filesystem::path getAppdir();
	CG *getCG();						// 05/17/99 AM.
	_TCHAR *getOutput();				// 05/18/99 AM.
	std::filesystem::path getOutdir();				// 05/18/99 AM.
	Eana *getErfa();					// 10/13/99 AM.

	// Modify
	void setGram(CONCEPT *);
	void setNLP(NLP *);
	void setAppdir(std::filesystem::path);
	void setCG(CG *);					// 05/17/99 AM.
	void setOutput(_TCHAR *);			// 05/18/99 AM.
	void setOutdir(std::filesystem::path);			// 05/18/99 AM.
	void setErfa(Eana *);			// 10/13/99 AM.

	// General.

	// Generate analyzer passes using Gram hierarchy.
	bool rugGenerate(
		bool justDirty=false,	// If only doing dirty concepts.	// 08/25/99AM.
		bool skipLocks=false		// If skipping locked concepts.	// 08/25/99AM.
		);

	// Remove generated passes.
	bool rmGenpasses();			// 05/31/99 AM.

	bool rmGenpasses(_TCHAR *stubname);	// 08/03/99 AM.

	// If current pass is a start stub pass.
	bool startStub(APASS *pass);		// 05/31/99 AM.

	// If current pass is an end stub pass.
	bool endStub(APASS *pass);			// 05/31/99 AM.

	// Get name of given stub pass.
	_TCHAR *stubName(APASS *pass);		// 06/01/99 AM.

	// Find stub concept in Gram hierarchy, given its name.
	CONCEPT *findStubconcept(	// 05/17/99 AM.
		_TCHAR *name,					// Name of stub, from analyzer sequence.
		CONCEPT *gram				// Top level of Gram hierarchy.
		);
	bool genTree(			// 05/17/99 AM.
		CONCEPT *tree,		// Concept immediately under Gram.  Matches analyzer
								// STUB pass.
		bool justDirty,	// If only doing dirty concepts.		// 08/25/99 AM.
		bool skipLocks,	// If skipping locked concepts.		// 08/25/99 AM
		/*DU*/
		APASS* &seq			// The last pass generated by genTree.
		);
	bool genTreeRec(		// 05/17/99 AM.
		CONCEPT *tree,		// Concept immediately under Gram.
								// Matches analyzer STUB pass.
		bool flag,			// True if root of subtree.
		Mode *mode,			// Info object.			// 07/19/99 AM.
		bool justDirty,	// If only doing dirty concepts.		// 08/25/99 AM.
		bool skipLocks,	// If skipping locked concepts.		// 08/25/99 AM
		/*DU*/
		APASS* &seq			// The last pass generated by genTree.
		);
	bool genoConcept(		// 06/26/99 AM.
		CONCEPT *conc,		// Current concept in Gram hierarchy.
		Mode *mode,			// 07/19/99 AM.
		bool justDirty,	// If only doing dirty concepts.		// 08/25/99 AM.
		bool skipLocks,	// If skipping locked concepts.		// 08/25/99 AM
		/*DU*/
		APASS* &seq			// The last pass generated by genxConcepts.
		);
	bool zapFile(_TCHAR *conname);		// 08/29/99 AM.
	bool zapFile(CONCEPT *conc);		// 08/29/99 AM.
	bool sampleFile(			// 06/26/99 AM.
		CONCEPT *sample,
		/*UP*/
		_TCHAR *input				// User-supplied buffer.
		);
	bool sameDoc(				// 06/26/99 AM.
		_TCHAR *fname,			// Current input document.
		CONCEPT *sample		// Sample whose document is being compared.
		);
	bool updateMode(			// 07/19/99 AM.
		Mode *mode,
		CONCEPT *conc
		);

	// Class-wide
	static void rugInit(CONCEPT *gram, CG *cg);			// 08/28/99 AM.

private:

	CONCEPT *gram_;			// Top of GRAM concept hierarchy.
	NLP *nlp_;						// Current analyzer.
	_TCHAR appdir_[MAXPATH];		// Base directory of analyzer app.
	CG *cg_;						// Current knowledge base.	// 05/17/99 AM.
	Eana *erfa_;				// Runtime config for RFA	// 10/13/99 AM.

	_TCHAR output_[MAXPATH*3];	// Output filename.			// 05/18/99 AM.
	_TCHAR outdir_[MAXPATH*2];	// Output directory.			// 05/18/99 AM.
	// NOTE: indir == appdir_\input .

// When code is well debugged and stable, can remove the stuff below.
#ifndef STABLE_
public:
	static int getCount();
	static void prettyCount();				// Pretty-print the count.
private:
	static int count_;						// Count nodes currently allocated.
#endif
};



#endif
/*************************      END OF FILE      ******************************/
